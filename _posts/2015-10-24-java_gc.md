---
layout: post
title: Java Garbage Collection
category: blog
tags: [java]
---
음 이거는.. 미완성 ㅋㅋㅋ 그냥 메모 용도로..

<!-- more -->

	Young 제너레이션				Old 제너레이션		Perm 제너레이션
	에덴 -  서바이버1 - 서바이버2           

* PermGen은 자바 애플리카에션 자체(클래스 등)가 로딩되는 영역으로 가비지컬렉션 대상이 아니다.

객체가 처음 생성(new) 되면 에덴 영역으로 들어감.
Minor 가비지컬렉션이 발생하면, 에덴과 서바이버1에 있던 객체 중 살아있는 것을 서바이버2로 복사. 나머지는 해제.
그다음에 또 Minor 가비지컬렉션이 발생하면 에덴과 서바이버2에 있던 객체 중 살아있는 것을 서바이버1로 복사. 나머지는 해제. 이런식으로 반복 수행.
그러다가 서바이버에서 오래 버틴 객체들은 Old 영역으로 옮겨진다. 이런 방식을 Copy & Scavenge(스캐빈지) 라고 함. 속도가 매우 빠름.


Old 영역에서의 가비지컬렉션은 Full 가비지컬렉션이라고 함. 전체 객체들의 참조를 확인하면서, 사용되지 않는 객체를 표시하여 삭제한다. 메모리 영역에 대한 compact가 필요하다.
속도가 매우 느리며 순간적으로 자바 애플리케이션이 멈춰버리는 Stop-the-world가 발생함. 즉 성능과 안전성에 영향을 준다,

그리구 PermGen에서도 가비지컬렉션이 일어난다.
Constant pool 때문인 것 같다.

스캐빈지, 마크, 컴팩트 등 여러가지 가비지컬렉션 알고리즘이 있으며, JVM에서도 4가지 방법을 지원하고 있음

### Heap 사이즈 튜닝에 따른 성능 변화
- Old영역의 크기를 줄이면, Full GC가 일어나는 횟수가 늘어나고, 횟수마다 걸리는 시간은 줄어들 것이다.
- 반대로 Old영역의 크기를 늘리면, Full GC가 일어나는 횟수는 줄어들겠지만 한 번 수행하는데 걸리는 시간은 늘어날 것이다.
- Full GC가 일어나는 횟수도 줄이고 시간도 줄이고 싶으면, Old 영역의 크기를 줄이고 여러개의 인스턴스를 동시에 띄워서 로드밸런싱을 해줄 수 있다. 


### 톰캣 튜닝
- `acceptCount`: 요청 큐의 길이. 너무 긴것 보다 0~10로 짧은게 좋음. 모든 쓰레드를 사용해도 요청을 처리하지 못하는 것은 이미 장애 상태일 가능성이 크므로 빨리 에러 응답을 주는게 나음.
- `maxConnection`: 하나의 톰캣 인스턴스가 유지할 수 있는 커넥션 갯수. 커넥션이 바로바로 닫히는 것이 아니므로 실제 동시 처리수는 이 값보다 작다.
- `maxThread`: 쓰레드 갯수. 순간 동시 처리 가능한 트랜잭션 수. 100 내외가 적절하고, 트랜잭션의 무게에 따라 50~500개. 성능 테스트를 통해 튜닝을 해가며 조정하는 것이 좋음.

------

References: 조대협님의 서버사이드 책